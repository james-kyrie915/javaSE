<h1 align="center"><b>Object Oriented Programming</b></h1>


[TOC]

# 面向对象上

#### java类及类的成员

```java
属性(字段)、方法、构造器;代码块、内部类

属性(字段)：类中的成员变量
行为：类中的成员方法
```

#### 面向对象的三个特征

```java
封装、继承、多态
```

#### 其它关键字

```java
this、super、static、final、abstract、interface、packet、import等
```

#### 面向过程(POP)和面向对象(OOP)

```markdown
pop:procedure oriented Programming
oop:Object Oriented Programming
二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。
```

#### 类(Class)和对象(Object)

```markdown
类：是对一类事物得到描述，是抽象的、概念上的定义
对象：是实际存在的该类事物的每个个体，因而称为实例(instance)
对象的引用：Person person = new Person();
person为对象的引用，new person()为类的实例（对象），类的实例=对象
创建类的对象 = 类的实例化 = 实例化类
对象，是由类new出来的，或者说是类派生出来的
创建类的对象：new + 构造器
```

补充：几个概念的使用说明

* 属性 = 成员变量 = field = 域、字段
* 方法 = 成员方法 = 函数 = method

* 创建类的对象 = 类的实例化 = 实例化类

#### 内存解析

![这里写图片描述](../features/20160326080347477.jpeg)

```markdown
堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配。

通常所说的栈( Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型( boolean、 byte、char 、 short 、 int 、 float 、 long .double ）、对象引用(reference类型它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。

方法区(Method Area），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
```

![image-20220807191151957](../features/image-20220807191151957.png)

内存解析的说明：

1. 引用数据类型的变量，只可能存储两类值：null 或 地址值(含变量的类型)

#### 类中属性的使用

```markdown 
(属性)成员变量 VS 局部变量：
1.相同点：
	1.1定义变量的格式：数据类型 变量名 = 变量值
	1.2先声明，后使用
	1.3变量都有其对应的作用域

2.不同点
	2.1在类中声明的位置不同
	成员变量(属性)：直接定义在类的一对{}内
	局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
	
	2.2关于权限修饰符的不同
	属性：可以在声明属性时，指明其权限，使用权限修饰符
 		 常用的权限修饰符：private、public、缺省(default)、protected		--->封装性后细说
	局部变量：不可以使用权限修饰符
	
	2.3默认初始化
	属性：类的属性，根据其类型，都有默认初始化值
		 整型(byte、short、int、long)：0
		 浮点型(float、double)：0.0
		 字符型(char)：0(或'\u0000')
		 布尔型(boolean)：false
		 
		 引用数据类型(类、数组、接口)：null
		 
		 
	局部变量：没有默认初始化值
			意味着，我们在调用局部变量之前，一定要显式赋值
			特别的：形参在调用时,我们赋值既可
			
	2.4在内存中加载的位置
	属性：加载到堆空间中（非static）
	局部变量：加载到栈空间
```

补充：回顾变量的分类：

方法一：按照数据类型分类：

![image-20220811061605306](../features/image-20220811061605306.png)

方法二：按照在类中声明的位置：

![image-20220811061801884](../features/image-20220811061801884.png)

#### 类中方法的声明和使用

```markdown
方法：描述类应该具有的功能
比如：
	 Math类：sqrt()\random()\...
	 Scanner类：nextXxx() ...
	 Arrays类：sort()\binarySearch()\toString()\equals\...

1.方法的声明：
权限修饰符 返回值类型 方法名(){
	方法体		
}
注意：static、final、abstract来修饰方法，后面再讲

2.说明
	2.1关于权限修饰符：
		java规定的四种权限修饰符：private、public、缺省(default)、protected		--->封装性后细说
	2.2返回值类型：有返回值 VS 没有返回值
		2.2.1如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字			  来返回执行类型的变量或常量：“return 数据”
			 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用				 return，但是，如果使用的话，只能“return;”表示结束此方法
			 
		2.2.2定义方法该不该有返回值？
			 ① 题目要求
			 ② 凭经验：具体问题具体分析
	2.3方法名：属于标识符，遵循标识符的规则和规范，“见名思意”
	2.4形参列表：方法可以声明0个，1个，或者多个形参。
	   2.4.1格式：数据类型1 形参1，数据类型2 形参2，...
	   
	   2.4.2我们定义方法时，该不该定义形参？
       		① 题目要求
       		② 凭经验：具体问题具体分析
3.方法的使用中，可以调用当前类的属性或方法
		特殊的：方法A中又调用了方法A，递归方法
		方法中，不可以定义方法
```

#### JVM内存解析

```markdown
1.虚拟机栈：即为我们平时提到的栈结构。我们将局部变量存储在栈结构中
2.堆：我们将new出来的结构(比如：数组、对象)加载在堆空间中。补充：对象的属性(非static)加载在堆中间中
3.方法区：类的加载信息、常量池、静态域
```

#### 对象数组的内存解析

```markdown
stus变量地址为0x7788
在未初始化数组之前，每个数组中的Student对象值为null
```

![image-20220811063806620](../features/image-20220811063806620.png)

#### 匿名对象的使用

```markdown
1.理解：我们创建的对象，没有显式的赋值给一个变量名。即称为匿名对象
2.特征：匿名对象只能调用一次
3.使用：1.new 类名().方法;
	   2.Student stu = new Student();
	     stu.learn(new Language()); //new Language()即为匿名类
```

#### 方法的重载

```markdwon
1.定义：在同一个类中（或子类和父类），允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同既可。
	"两同一不同":同一个类（或子类和父类）、相同的方法名
			   参数列表不同：参数个数不同，参数类型不同

2.举例：
	Arrays类中重载的sort() / binarySearch()

3.判断是否是重载：
	跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系

4.在通过对象调用方法时，如何确定某一个指定的方法：
	方法名 ---> 参数列表
```

```markdown
1.jdk 5.0新增的内容
2.具体使用:
    2.1 可变个数形参的格式:数据类型...变量名
    2.2当调用可变个数形参的方法时，传入的参数个数可以是:0个，1个,2个，。。。
    2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
    2.4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存
    2.5可变个数形参在方法的形参中，必须声明在末尾
	2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参
```

#### 关于变量的赋值

```markdown
如果变量是基本数据类型，此时赋值的是变量所保存的数据值
如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值
```

##### 方法的形参的传递机制：值传递

```markdwon
1.形参:方法定义时，声明的小括号内的参数
  实参:方法调用时，实际传递给形参的数据
   
2.值传递机制:
  如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值
  如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值(含变量的数据类型)
```

![image-20220813160249248](../features/image-20220813160249248.png)

![image-20220813160120000](../features/image-20220813160120000.png)

#### 封装性

```markdown
程序设计追求：高内聚、低耦合

高内聚：类的内部数据操作细节自己完成，不允许外部干涉
低耦合：仅对外暴露少量的方法用于使用

封装性的理解：隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想
```

**封装性的体现**：

我们将类的属性xxx私有化(private)，同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值

​	拓展：封装性的体现：① 如上② 不对外暴露私有的方法③ 单例模式 ...

**封装性的体现，需要权限修饰符来配合**：

```markdown
1.Java规定的4种权限（从小到大排列): private、缺省(default)、protected、public
2.4种权限可以用来修饰类及类的内部结构:属性、方法、构造器、内部类
3.具体的，4种权限都可以用来修饰类的内部结构:属性、方法、构造器、内部类
	修饰类的话，只能使用：却省(default)、public

总结封装性:Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小
```

**四种访问权限修饰符**：

![image-20220814172208246](../features/image-20220814172208246.png)

#### 构造器

```markdown
类的结构之三:构造器（或构造方法、constructor）的使用

一、构造器的作用:
1.创建对象
2.初始化对象的属性

二、说明:
1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
2.定义构造器的格式:权限修饰符 类名(形参列表){}
3.一个类中定义的多个构造器，彼此构成重载
4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
5.一个类中,至少会有一个构造器。
```

```java
JavaBean是一种Java语言写成的可重用组件。
所谓javaBean，是指符合如下标准的Java类:
	>类是公共的
	>有一个无参的公共的构造器
	>有属性，且有对应的get. set方法
```

#### 关键字：this的使用

```markdown
this关键字的使用:
1.this可以用来修饰、调用:属性、方法、构造器

2.this修饰属性和方法:
this理解为:当前对象或当前正在创建的对象

	2.1在类的方法中，我们可以使用"this .属性"或"this.方法"的方式，调用当前对象属性或方法。但是通常情况下，我们都选择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
	2.2在类的构造器中，我们可以使用"this.属性"或"this.方法""的方式，调用当前当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式,表明此变量是属性，而非形参。

3.this调用构造器
	① 我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器
	② 构造器中不能通过"this(形参列表)"方式调用自己
	③ 如果一个类中有n个构造器，则最多有n -1构造器中使用了"this(形参列表)"
	④ 规定:"this(形参列表)"必须声明在当前构造器的首行
	⑤ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器
```

#### 关键字：package的使用

```java
一、package关键字的使用
1.为了更好的实现项目中类的管理，提供包的概念
2.使用package声明类或接口所属的包，声明在源文件的首行
3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”
4.每"."一次，就代表一层文件目录。

补充：同一个包下，不能命名同名的接口、类
	 不同的包下，可以命名同名的接口、类
```

#### 关键字：import的使用

```java
import:导入
1.在源文件中显式的使用import结构导入指定包下的类、接口
2.声明在包的声明和类的声明之间
3.如果需要导入多个结构，则并列写出即可
4.可以使用"xxx.*"的方式，表示可以导入xxx包下的所有结构
5.如果使用的类或接口是java.lang包下定义的，则可以省略import结构
6.如果使用的类或接口是本包下定义的，则可以省略import结构
7.如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示
//全类名的方式显示
	com.javase.Account account = new com.javase.Account();
8.使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入
9.import static:导入指定类或接口中的静态结构:属性或方法。
```

#### 回顾复习

